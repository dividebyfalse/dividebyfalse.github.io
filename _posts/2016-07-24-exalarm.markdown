---
layout: post
title: "Лайкни бывшую(ого) в инстаграм. Часть 1"
date: "2016-07-24 19:37:06 +0800"
tags: ios swift draft
---

![start]({{ site.baseurl }}/images/exAlarm/Chapter01/0.jpg)

**Attention** В iOS 10 будет обновленный механизм уведомлений, поэтому данный цикл постов потерял актуальность во время написания. Так что отложу до выхода iOS 10. А пока можете поглядеть, как это могло бы быть на  iOS 9.3. Кстати вводится новый тег **[#draft]({{ site.baseurl }}/search?t=draft)**. Обозначает посты, которые недописаны, и не имеют мотивов быть дописаными, но выложить хочется. Именно поэтому данный пост часто скатывается к набору картинок и кода. Потому что подробно объяснять нет смысла, так как многое изменится. Орфография, пунктуция и прочее сохранены с момента получения информации об iOS 10. Добавлены лишь небольшие комментарии. Так что возможно много ошибок и мусора в тексте.

И ещё. Для тех, кто хоть чуточку шарит, достаточно будт глянуть код (которого вот прям совсем чуть-чуть) и не читать многобукв.

### Вступление

После нескольких безуспешных попыток **быстро** подружиться с iOS + Objective-C, было решено не насиловать этот труп. Временем я своим дорожу и потому жалею, что не понял этого ранее. Ну и как догадались читатели "в теме", я принялся изучать iOS + Swift.
<!--more-->

Никогда не знаешь, где можешь подхватить идею приложения для тренировки. В этот раз помог твиттер. Буду делать будильник, который ставит лайк бывшей в инстаграмм, при нажатии на кнопку "Отложить на 5 минут". Помимо этой простой киллерфичи есть идея добавить и другие методы борьбы с "сонями". Например снимать по 10 рублей за каждое "откладывание на 5 минут" хе-хе. Пока не знаю на сколько это реализуемо (через внутренние покупки/подписку или через платные смс) :smiley: Идей на самом деле много, но о них потом. 

Всё что описывается ниже написано в **XCode 7.3.1** и протестировано на эмуляторе с **iOS 9.3**. В самом первом посте я говорил, что буду всё очень подробно описывать. С тех пор планы не изменились. Это первая часть из...нескольких. Посмотрим как пойдёт.

### Постановка задачи
  * Разработать **будильник** который ставит лайк бывшей девушке либо бывшему парню в инстаграм при клике на кнопку "Отложить на 5 минут". 
  * Выложить всё это дело в AppStore. Потому что мне не на ком пробовать :)0)

Для такого простого приложения здесь достаточно мелких задач, которые задействуют много сторон разработки приложений. Тут и хранение данных, и работа с внешним API, и механизм нотификаций iOS (уведомления, которые всех уже достали), ну и конечно же основы работы с контроллерами, вьюшками и обработчиками событий. В общем, если вы совсем ноль, то надеюсь данный цикл статей поможет вам немножк втянуться в iOS разработку. Желательно конечно иметь опыт хоть какого-нибудь программирования. Но я буду стараться писать ОЧЕНЬ подробно, надеюсь что не зря (всё-таки зря :sob:).

В данном посте будет рассмотрено устройство наипростейшего будильника, который только и может, что ставить напоминалку со звуком на определённое время.

### Шаг 0. В добрый путь.
Счастливый ли вы обладатель устройства с Mac OS, или красноглазый пользователь Hackintosh - неважно. Дуй ставить **последний** XCode. Как же я быстро перешёл на ты однако.

Что? Тебе **лень** обновляться? Ну тогда пиздуй отсюда. Я сказал последний! Ты ещё не работаешь в старой и большой компании, чтобы пользоваться древними инструментами только потому, что нужно поддерживать старые продукты.

Последний XCode и тот, что указан в этом посте **различаются**? Ну чтож, добро пожаловать в жестокий мир программистов. Велика вероятность того, что код, приведенный в данном посте не будет работать (как в воду глядел бля). Что делать в таком случае? <strike>Уткнуться в подушку и плакать</strike>. Гуглить и СПРАШИВАТЬ у других людей. Если не гуглится, то по-хорошему лучше задать вопрос на **[stackoverflow](http://stackoverflow.com)**, чтобы другим было проще. Но бывает, что нет времени ждать ответа там, и на помощь приходят мессенджеры и тематические чатики. Но помни, что канал об аниме уже не патчит. Полно живых тематических каналов в том же Telegram, ну или если хочешь почуствовать себя кулцхакером и знаешь английский, то заходи в **IRC**. Ньюфаги плюются, старпёры текут. IRC живее всех живых ещё. Да и взрослее/мудрее к тому же. Что-то я отвлёкся малёх. У нас впереди много работы.

### Шаг 1. Создаём проект.

XCode поставили/обновили. Запускаем, и видим следующее окошко.

<img alt="" src="{{ site.baseurl }}/images/exAlarm/Chapter01/1.png" usemap = "#genlinks0"/>
Рис. 1

Погнали по порядку.

1. **<a class="rctlink0" href="">Песочница.</a>** Позволяет быстро попробовать написать что-то на Swift. Для шарящих - это типо <span class="tooltip">REPL <span>Read-eval-print loop — простая интерактивная среда программирования.<br>**<a href="https://ru.wikipedia.org/wiki/REPL">Подробнее...</a>**</span></span> с гуем. Для не шарящих - попробуйте и сразу поймёте.
2. **<a class="rctlink1" href="">Создать проект XCode.</a>**
3. **<a class="rctlink2" href="">Открыть проект из</a>** <span class="tooltip"> **репозитория** <span>**Репозиторий, хранилище** - место, где хранятся и поддерживаются какие-либо данные. Чаще всего данные в репозитории хранятся в виде файлов, доступных для дальнейшего распространения по сети.<br>**<a href="https://ru.wikipedia.org/wiki/Репозиторий">Подробнее...</a>**</span></span>.

Жмем **<a class="rctlink1" href="">"Create a new XCode project"</a>** и видим окно выбора типа приложения, которое мы будем создавать. Тут на самом деле представлены шаблоны, с помощью которых можно быстро накидать разные типы приложений. По названиям и картинкам легко догадаться, какие приложения создают эти шаблоны.  Мы же не выебываемся и идем с нуля, поэтому жмакаем на **"Single View Application"**.

![2]({{ site.baseurl }}/images/exAlarm/Chapter01/2.png)

Дальше заполняем инфу о приложении и ставим галочку Use Core Data. Понадобится в дальнейшем, а пока забей.

![3]({{ site.baseurl }}/images/exAlarm/Chapter01/3.png)

И вуаля! У нас есть приложуха, которая ничего не умеет. Чтобы запустить её, нужно кликнуть по **<a class="rctlink3" href="#">кнопке</a>**.

<img alt="" src="{{ site.baseurl }}/images/exAlarm/Chapter01/4.png" usemap = "#genlinks1"/>

### Шаг 2. Разрешаем уведомлять.

Дальше нам нужно разрешить приложению использовать уведомления. Для этого обратимся к методу `registerUserNotificationSettings` класса `UIApplication`. В файле `AppDelegate.swift` есть функция `application` которая выполняется как раз после запуска нашего приложения. Важный момент. Здесь идет только запуск приложения, не факт, что оно полностью запустится до того момента как функция начнет выполнятся. Это то самое место, где мы можем задать настройки приложения и сказать ему, что оно будет отсылать уведомления. Метод `registerUserNotificationSettings` на вход принимает объект `UIUserNotificationSettings` (будет репрессирован в iOS 10 :sob: ) . У этого объекта два поля: `types` и `categories`. 

В `types` указывается типы уведомлений, которые разрешается использовать. В нашем случае `Sound` и всплывающее окошко `Alert`. Есть ещё `Badges`. Это такие красные кружочки с циферками над иконкой приложения. 

В `categories` указываются категории с `Actions`. Действиями, которые можно выполнить при просмотре уведомления. Ну типо там "Открыть приложение", "Отложить будильник на 5 минут" и т.д. А так как действия могут быть разными в зависимости от ситуации, то для этого и нужны категории. Здесь пока ничего не будем указывать, займемся созданием категорий и самих действий позже.

На основе вышесказанного, неоходимо добавить следующий код в функцию `application` в файле `AppDelegate.swift`. В метод `registerUserNotificationSettings` передаём объект `UIUserNotificationSettings` с типами `Sound` и `Alert`. В категории передаём `nil`

{% highlight swift %}
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: 
    [NSObject: AnyObject]?) -> Bool {
    
    application.registerUserNotificationSettings(UIUserNotificationSettings(
        forTypes: [.Sound, .Alert], categories: nil))
        
    return true 
}
{% endhighlight %}

Теперь при запуске увидим запрос на разрешение отсылать уведомления из нашего приложения. Супер.

### Шаг 3. Кодим мышкой раз.

Теперь идем в файл `Main.storyboard`. Тут мы видим внешний вид нашего приложения. Дважды жмем в визуальном редакторе на `View Controller`. Перед глазами у вас должно быть что-то типо этого.

<img alt="" src="{{ site.baseurl }}/images/exAlarm/Chapter01/5.png" usemap = "#genlinks2"/>

Немного разберём интерфейс.

* **<a class="rctlink4" href="#">Файловый менеджер</a>**
* **<a class="rctlink5" href="#">Окно работы с файлами .storyboard.</a>** Кодинг мышкой.
* **<a class="rctlink6" href="#">Всевозможные настройки и свойства объектов.</a>** Кодинг мышкой. Для дальнейшего удобства перейдите на 4-ую вкладку (как на скриншоте), и выберите Size = iPhone 5.5-inch.
* **<a class="rctlink7" href="#">Каталог элементов (View).</a>**

Листаем наш каталог и мышкой вытаскиваем оттуда два объекта: `Button` и `DatePicker`. Размещаем как душе угодно в визуальном редакторе. Дальше идём в правый верхний угол и жмём на два кружочка. Появляется текстовый редактор с открытым файлом `ViewController.swift`. Мало места? Побалуйся **<a class="rctlink8" href="">здесь.</a>**

<img alt="" src="{{ site.baseurl }}/images/exAlarm/Chapter01/6.png" usemap = "#genlinks3"/>

### Шаг 4. Кодим мышкой два.

Теперь самое интересное. Лично я не люблю IDE, потому что иногда они творят какую-то магию. Как например дальше. Зажмите кнопку Alt и зажмите кнопку мыши на объекте `DatePicker`. Перетащите мышку в текстовый редактор. За мышкой должна вести синяя линия. Отпустите мышку перед функцией `viewDidLoad()`.

Вылезет следующее окно.

<img alt="" src="{{ site.baseurl }}/images/exAlarm/Chapter01/7.png"/>

Заполняем имя и жмем Connect. Дальше туже процедуру повторяем с кнопкой, только в пункте Connection выбираем Action. И вставляем лучше это куда-нибудь в конец. После функции `didReceiveMemoryWarning()` например.

<img alt="" src="{{ site.baseurl }}/images/exAlarm/Chapter01/8.png"/>

Что же сейчас сделали? Мы связали визуальное представление объектов с кодом приложения. Эта связь описывается в файле `Main.storyboard`, который по своей сути является обычным XML файлом. То есть сначала связали `DatePicker` с каким-то именем (в моем случае `DataSet`) и добавили обработчик (у меня `SetAlarm`) на кнопку.

### Шаг 5. Обрабатываем нажатие на кнопку.

Теперь заполним кодом наш обработчик. Тут на самом деле всё просто. Сначала создаём объект уведомления. Потом задаём ему определенные свойства. Например сообщение, которое выводится в уведомлении (`alertBody`), мелодия (`soundName`) и наконец дату (`fireDate`), когда это уведомление вызвать. **[Мелодию](http://onlineclock.net/audio/options/police-car.mp3)** надо закинуть в проект, простым перетаскиванием из Finder в файловый менеджер XCode. Дату вызова берем из объекта DatePicker (`DataSet.date`). После всего добавляем наше уведомление в так называемое "расписание" телефона c помощью `scheduleLocalNotification()`. Теперь оно не зависит от работоспособности самого приложения и вызовется по указанной дате. В итоге код обработчика нажатия на кнопку будет следующий:

{% highlight swift %}
    @IBAction func SetAlarm(sender: AnyObject) {
        let notification:UILocalNotification = UILocalNotification()
        notification.alertBody = "Hello!"
        notification.soundName = "police-car.mp3"
        notification.fireDate = DataSet.date
        UIApplication.sharedApplication().scheduleLocalNotification(notification)
    }
{% endhighlight %}

### Шаг 6. Тестируем.

А теперь тестируем! Выставляем дату (например на минуту вперёд). Жмем на кнопку. Выходим из приложения (⌘⇧H), ждём, видим и слышим :) Тип уведомления можно изменить в настройках.

<img alt="" src="{{ site.baseurl }}/images/exAlarm/Chapter01/10.png"/>

### Итог

Данный пост станет абсолютно бесполезным через месяц (а я как раз через месяц и хотел закончить цикл постов). Пусть это будет мне уроком. Но я хоть потренировался в написании технотекстов и немножко прокачал блог (всплывающие подсказки и подсвечивание областей картинок). Хотя тут ещё писать и писать, а для полного подробного объяснения ещё очень далеко. Ну да ладно. Спасибо, что читаете. Всего доброго, не болейте :wink:! 

<map name="genlinks0">
    <area id="rct0" href="#" shape="rect" coords="120,300,520,350" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
    <area id="rct1" href="#" shape="rect" coords="120,350,520,400" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
    <area id="rct2" href="#" shape="rect" coords="120,400,520,450" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
</map>

<map name="genlinks1">
    <area id="rct3" href="#" shape="rect" coords="50,20,110,35" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
</map>

<map name="genlinks2">
    <area id="rct4" href="#" shape="rect" coords="0,40,170,600" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
    <area id="rct5" href="#" shape="rect" coords="170,40,670,600" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
    <area id="rct6" href="#" shape="rect" coords="670,40,840,360" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
    <area id="rct7" href="#" shape="rect" coords="670,360,840,600" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
</map>

<map name="genlinks3">
    <area id="rct8" href="#" shape="rect" coords="630,20,820,65" alt="Octoface" data-maphilight="{'stroke':false,'fillColor':'ff0000','fillOpacity':0.6}" title="Metadata">
</map>
